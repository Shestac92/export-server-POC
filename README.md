# export-server-POC

## Usage

`npm install`

`npm run start`

Картинки складываются `./screenshots`.

Чтобы руками вызвать экспорт, то нужно сделать POST запрос на `localhost:3000` с JSON в body:
```
{
"config": {
  "chart": {
    "type": "pie",
    "data": [
      {"x": "Кириллица", "value": "28.15", "fill": "green"},
      {"x": "Oranges", "value": "128.14", "fill": "orange"}
    ]
  }
},
"width": 300,
"height": 400
}
```

или

```
{
"config": {
"chart": {
    "type": "column",
    "series":[{
"data": [128.14, 112.61, 163.21, 229.98]
    }]
}
},
"width": 800,
"height": 400
}

```

А можно сделать нагрузочное тестирование. Параллельно во втором окне терминала вызвать `npm run load-test`.
На моей машине локально стабильно держит нагрузку 17 запросов в секнду.
### Мысли

В одном браузере можно создать несколь контекстов с разным view-port. Каждый контекст может параллельно работать
с множеством страниц. Но тогда у них одинакоывй контекст и размеры окна.
Чтобы делать одновременно скриншоты разных размеров, то нужно либо запускать разные контексты либо прокидывать размер графика в HTML
и скринить (только нужную часть графика)[https://playwright.dev/docs/screenshots#element-screenshot]. Короче надо изучать что быстрее.

Кастомные шрифты и языки.

### Результаты нагрузки

1. Все в одной вкладке. Работает быстро, но как только кол-во запросов в секунду превышает скорость, с которой ответы отдает сервер, создается очередь и начинает сервер тонуть.

2. Каждый запрос отдельной вкладке. Это должно было по идее исключить проблему с очередью запросов. Но нет! Во-первых, это самый медленный способ,
под каждый запрос создается вкладка, а для нее весь изолированный контекст. Это занимает много времени. И результат оказался даже хуже чем в предыдущем варианте,
потому что браузер тратит кучу ресурсов на создание вкладок и контекстов, при определенной нагрузке создается по итогу очередь на создвание вкладок, потом заканчивается
память и приплыли.

Как мне кажется, нужно сделать по аналогии с Qlik тестилкой только без воркеров. Есть один браузер с N заготовленных вкладок, с уже готовым контекстом.
N вкладок определяется заранее в конфиге, так получится управлять расходом памяти. Ну и при входящем запросе на экспорт выбирается первая же свободная вкладка. Если нет, то уже да, создается очередь.

3. Оптимальным кол-вом кажется оказалось 5 вкладок. Больше просто нужно самому браузеру хендлить, а меньше не хватает.

### Исполнение пользовательского JS кода

Тут встает вопрос безопасности. Никто не хочет копрометировать свой сервер.
Однако, браузер - сама по себе изолированная среда, из браузера о сервера почти ничего не узнать и не поломать. Но можно поломать сам браузер, например,
наоткрывать кучу вкладок на левые ресурсы или использовать экспорт сервер как бота для DDoS-атак. Надо подумать как все это обезопасить,
вроде как playwright позволяет (это сделать)[https://playwright.dev/docs/network#http-authentication].

### TODO
- WTF с повторной отрисовкой
- возврат картинки в ответе
- исполнение пользовательского JS-кода, с проверкой origin!
- как альтернатива - использование шаблонов с заготовленным JS кодом, куда только данные из JSON вставляются.
  То есть клиент передает только данные и ID шаблона